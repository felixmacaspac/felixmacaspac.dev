---
import { experiences } from '../../data/experiences';
import type { SectionProps } from '../types';

export type Props = SectionProps;

const { id = "experience", className = '' } = Astro.props satisfies SectionProps;
---

<section id={id} class={`max-w-2xl mx-auto px-6 pb-20 ${className}`}>
  <h2 class="experience-item opacity-0 translate-y-4 transition-all duration-700 ease-out text-sm font-semibold mb-8" data-index="0">latest experience</h2>
  
  <div class="space-y-10">
    {experiences.map((exp, index) => (
      <div class="experience-item opacity-0 translate-y-4 transition-all duration-700 ease-out group" data-index={index + 1}>
        <div class="flex items-start gap-4">
          <div class="w-12 h-12 bg-zinc-900 border border-zinc-800 rounded-lg flex-shrink-0 mt-1 overflow-hidden">
            {exp.image ? (
              <img 
                src={exp.image} 
                alt={`${exp.company} logo`}
                class="w-full h-full object-contain p-2 bg-white"
              />
            ) : (
              <div class="w-full h-full bg-zinc-800"></div>
            )}
          </div>
          <div class="flex-1 space-y-1">
            <div class="flex items-baseline justify-between">
              <h3 class="font-medium text-base">
                {exp.role}
              </h3>
              <span class="text-xs text-zinc-400 font-mono">
                {exp.period}
              </span>
            </div>
            <p class="text-sm text-white font-medium">
              {exp.company}
            </p>
            <p class="text-sm text-zinc-300 leading-relaxed pt-1">
              {exp.description}
            </p>
          </div>
        </div>
      </div>
    ))}
  </div>
</section>

<script>
  function initExperienceAnimations() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const item = entry.target as HTMLElement;
          const index = parseInt(item.getAttribute('data-index') || '0');
          
          setTimeout(() => {
            item.classList.remove('opacity-0', 'translate-y-4');
            item.classList.add('opacity-100', 'translate-y-0');
          }, index * 150);
          
          observer.unobserve(item);
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    });

    document.querySelectorAll('.experience-item').forEach((item) => {
      observer.observe(item);
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initExperienceAnimations);
  } else {
    initExperienceAnimations();
  }
</script>
